#include <{{ package_name }}/{{ controller_name }}.hpp>

#include <algorithm>
#include <chrono>
#include <functional>

#include <rclcpp/duration.hpp>
#include <rclcpp/logging.hpp>
#include <rclcpp/time.hpp>
#include <rclcpp/qos.hpp>
#include <rclcpp/serialized_message.hpp>
#include <rclcpp_lifecycle/state.hpp>

#include <controller_interface/controller_interface_base.hpp>
{% if has_subscriber %}
#include "realtime_tools/realtime_buffer.hpp"
{% endif %}

namespace {{ package_name }} {

  controller_interface::InterfaceConfiguration {{ controller_class_name }}::command_interface_configuration() const {
  controller_interface::InterfaceConfiguration config;

  // TODO: Make some general example (though maybe Franka robot is a general enough?)
  // TODO: Add constants needed in this function to .hpp file
  // TODO: Replace with semantic component (only works if we use Franka controller)
  config.type = controller_interface::interface_configuration_type::INDIVIDUAL;
  for (size_t index = 1; index <= N_JOINTS; index++) {
    config.names.push_back("fr3_joint" + std::to_string(index) + "/effort");
  }

  return config;
}

controller_interface::InterfaceConfiguration {{ controller_class_name }}::state_interface_configuration() const {
  controller_interface::InterfaceConfiguration config;

  // TODO: Make some general example (though maybe Franka robot is a general enough?)
  // TODO: Add constants needed in this function to .hpp file
  config.type = controller_interface::interface_configuration_type::INDIVIDUAL;
  for (size_t index = 1; index <= N_JOINTS; index++) {
    config.names.push_back("fr3_joint" + std::to_string(index) + "/position");
    config.names.push_back("fr3_joint" + std::to_string(index) + "/velocity");
  }

  return config;
}

controller_interface::CallbackReturn {{ controller_class_name }}::on_init() {
  try {
    // TODO: Make some general example (though maybe Franka robot is a general enough?) e.g. accept joint names and types (https://github.com/ros-controls/ros2_controllers/blob/humble/forward_command_controller/include/forward_command_controller/forward_command_controller.hpp)
    // TODO: Generate parameters with generate_parameter_library? (common in ros2_controllers repo) (https://github.com/PickNikRobotics/generate_parameter_library)
    auto_declare<std::vector<double>>("k_gains", {});
    auto_declare<std::vector<double>>("d_gains", {});
    auto_declare<double>("velocity_filter_alpha_gain", 0.99);
{% if has_subscriber %}
    auto_declare<std::string>("cmd_topic", "~/cmd_vel");
{% endif %}
{% if has_publisher %}
    auto_declare<std::string>("state_topic", "~/commanded_state");
{% endif %}
  } catch (const std::exception &e) {
    (void)fprintf(stderr, "Exception thrown during init stage with message: %s \n", e.what());
    return CallbackReturn::ERROR;
  }
  return CallbackReturn::SUCCESS;
}

controller_interface::CallbackReturn {{ controller_class_name }}::on_configure(
    const rclcpp_lifecycle::State & /*previous_state*/
  ) {
  // Get k-gains from parameter
  auto k_gains_param = get_node()->get_parameter("k_gains").as_double_array();
  if (k_gains_param.empty()) {
    RCLCPP_FATAL(get_node()->get_logger(), "k_gains parameter not set");
    return CallbackReturn::FAILURE;
  }
  if (k_gains_param.size() != N_JOINTS) {
    RCLCPP_FATAL(
      get_node()->get_logger(), "k_gains should be of size %zu but is of size %ld", N_JOINTS, k_gains_param.size()
    );
    return CallbackReturn::FAILURE;
  }

  // Get d-gains from parameter
  auto d_gains_param = get_node()->get_parameter("d_gains").as_double_array();
  if (d_gains_param.empty()) {
    RCLCPP_FATAL(get_node()->get_logger(), "d_gains parameter not set");
    return CallbackReturn::FAILURE;
  }
  if (d_gains_param.size() != N_JOINTS) {
    RCLCPP_FATAL(
      get_node()->get_logger(), "d_gains should be of size %zu but is of size %ld", N_JOINTS, d_gains_param.size()
    );
    return CallbackReturn::FAILURE;
  }

  // Store gains
  for (size_t index = 0; index < N_JOINTS; index++) {
    d_gains_(static_cast<int>(index)) = d_gains_param.at(index);
    k_gains_(static_cast<int>(index)) = k_gains_param.at(index);
  }

  // Get single-valued parameters
  velocity_filter_alpha_gain_ = get_node()->get_parameter("velocity_filter_alpha_gain").as_double();

{% if has_subscriber %}
  try {
    auto cmd_topic_param = get_node()->get_parameter("cmd_topic").as_string();
      // Register commanded state publisher
      subscriber_ = get_node()->create_subscription<CmdMsg>(
        cmd_topic_param, 
        rclcpp::SystemDefaultsQoS(),
        [this](const CmdMsg::SharedPtr msg) { rt_command_ptr_.writeFromNonRT(msg); }
      );
  } catch (const std::exception & e) {
    fprintf(
      stderr, "Exception thrown during subscription creation at configure stage with message : %s \n",
      e.what());
    // TODO: Check if we should return ERROR or FAILURE
    return controller_interface::CallbackReturn::ERROR;
  }

{% endif %}
{% if has_publisher %}
  try {
    auto state_topic_param = get_node()->get_parameter("state_topic").as_string();
      // Register commanded state publisher
      publisher_ = get_node()->create_publisher<StateMsg>(state_topic_param, rclcpp::SystemDefaultsQoS());
      realtime_publisher_ = std::make_unique<RtStatePublisher>(publisher_);
  } catch (const std::exception & e) {
    fprintf(
      stderr, "Exception thrown during publisher creation at configure stage with message : %s \n",
      e.what());
    // TODO: Check if we should return ERROR or FAILURE
    return controller_interface::CallbackReturn::ERROR;
  }

{% endif %}
    RCLCPP_INFO(get_node()->get_logger(), "Configure successful");
    return CallbackReturn::SUCCESS;
  }

controller_interface::CallbackReturn {{ controller_class_name }}::on_cleanup(
    const rclcpp_lifecycle::State & /*previous_state*/
  ) {

  // Reset parameters
  velocity_filter_alpha_gain_ = 0.0;
  for (size_t index = 0; index < N_JOINTS; index++) {
    d_gains_(static_cast<int>(index)) = 0;
    k_gains_(static_cast<int>(index)) = 0;
  }

{% if has_subscriber %}
  // Remove subscriber
  subscriber_.reset();
{% endif %}
{% if has_publisher %}
  // Remove publisher
  publisher_.reset();
  realtime_publisher_.reset();
{% endif %}

  RCLCPP_INFO(get_node()->get_logger(), "Cleanup successful");
  return CallbackReturn::SUCCESS;
}

controller_interface::CallbackReturn {{ controller_class_name }}::on_activate(
    const rclcpp_lifecycle::State & /*previous_state*/
  ) {

  // Reset internal variables
  filtered_joint_velocities_.setZero();

  // Reset command buffer in case a command came in when controller was inactive
  rt_command_ptr_ = realtime_tools::RealtimeBuffer<std::shared_ptr<CmdMsg>>(nullptr);

  RCLCPP_INFO(get_node()->get_logger(), "Activate successful");
  return controller_interface::CallbackReturn::SUCCESS;
}

controller_interface::CallbackReturn {{ controller_class_name }}::on_deactivate(
    const rclcpp_lifecycle::State & /*previous_state*/
  ) {

  // Reset internal variables
  filtered_joint_velocities_.setZero();

  // Reset command buffer
  rt_command_ptr_ = realtime_tools::RealtimeBuffer<std::shared_ptr<CmdMsg>>(nullptr);

  RCLCPP_INFO(get_node()->get_logger(), "Deactivate successful");
  return controller_interface::CallbackReturn::SUCCESS;
}

controller_interface::return_type {{ controller_class_name }}::update(
    {% if has_publisher %}const rclcpp::Time & time{% else %}const rclcpp::Time & /*time*/{% endif %}, const rclcpp::Duration & /*period*/
  ) {

  // Obtain current joint states from state interfaces
  Vector7d curr_joint_positions;
  Vector7d curr_joint_velocities;
  for (size_t index = 0; index < N_JOINTS; index++) {
    // This is currently a pretty "dumb" way to obtain Franka states, but we assume 
    // that every even state interface is a position and every odd is velocity.
    // TODO: Use semantic components to obtain states instead
    const auto &position_interface = state_interfaces_.at(2 * index);
    const auto &velocity_interface = state_interfaces_.at(2 * index + 1);

    if (position_interface.get_interface_name() != "position") {
      RCLCPP_ERROR_THROTTLE(
        get_node()->get_logger(), *(get_node()->get_clock()), 1000,
        "Interface with name \"%s\" does not match \"position\" at state index %zu for joint %zu",
        position_interface.get_interface_name().c_str(), 2 * index, index);
      // The controller should stop (or in Humble, spam errors)
      return controller_interface::return_type::ERROR;
    }
    if (velocity_interface.get_interface_name() != "velocity") {
      RCLCPP_ERROR_THROTTLE(
        get_node()->get_logger(), *(get_node()->get_clock()), 1000,
        "Interface with name \"%s\" does not match \"velocity\" at state index %zu for joint %zu",
        position_interface.get_interface_name().c_str(), 2 * index + 1, index);
      // The controller should stop (or in Humble, spam errors)
      return controller_interface::return_type::ERROR;
    }

    curr_joint_positions(static_cast<int>(index)) = position_interface.get_value();
    curr_joint_velocities(static_cast<int>(index)) = velocity_interface.get_value();
  }

{% if has_subscriber %}
  // Read the commands from the real-time buffer
  std::shared_ptr<CmdMsg>* joint_command_msg = rt_command_ptr_.readFromRT();

  // Check if a command is received yet
  if (!joint_command_msg || !(*joint_command_msg)) {
    // No command received yet, continue the controller without setting an output
    return controller_interface::return_type::OK;
  }

  // Check if the received command has the correct number of values
  auto joint_command_values = (*joint_command_msg)->data;
  if (joint_command_values.size() != N_JOINTS) {
    RCLCPP_ERROR_THROTTLE(
      get_node()->get_logger(), *(get_node()->get_clock()), 1000,
      "Command size (%zu) does not match number of joints (%zu)",
      joint_command_values.size(), N_JOINTS);
    // The controller should stop (or in Humble, spam errors)
    return controller_interface::return_type::ERROR;
  }

  // Put the commands into a vector
  Vector7d joint_commands;
  for (size_t index = 0; index < N_JOINTS; index++) {
    joint_commands(static_cast<int>(index)) = joint_command_values[index];
  }
{% else %}
  // TODO: Compute joint commands internally

{% endif %}

  // Calculate the torque command
  filtered_joint_velocities_ = (1 - velocity_filter_alpha_gain_) * filtered_joint_velocities_ +
                                    velocity_filter_alpha_gain_ * curr_joint_velocities;
  Vector7d commanded_joint_torques = k_gains_.cwiseProduct(joint_commands - curr_joint_positions) +
                                   d_gains_.cwiseProduct(-filtered_joint_velocities_);

  // Set the commands as output
  for (size_t index = 0ul; index < N_JOINTS; ++index) {
    command_interfaces_[index].set_value(commanded_joint_torques(static_cast<int>(index)));
  }

{% if has_publisher %}
  // Also publish the commanded state to the real time publisher
  if (realtime_publisher_ && realtime_publisher_->trylock()) {
    realtime_publisher_->msg_.header.stamp = time;
    for (size_t index = 0ul; index < N_JOINTS; ++index) {
      realtime_publisher_->msg_.data[index] = commanded_joint_torques(static_cast<int>(index));
    }
    realtime_publisher_->unlockAndPublish();
  }

{% endif %}
  return controller_interface::return_type::OK;
}

}

// Export the controller as a pluginlib plugin

#include <controller_interface/controller_interface.hpp>
#include <pluginlib/class_list_macros.hpp>

PLUGINLIB_EXPORT_CLASS(
  {{ package_name }}::{{ controller_class_name }}, 
  controller_interface::ControllerInterface
)